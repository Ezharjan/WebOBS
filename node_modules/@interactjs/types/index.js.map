{
	"version": 3,
	"sources": [
		"index.ts"
	],
	"names": [
		"interaction"
	],
	"mappings": "AAAA;AAOA,OAAO,KAAKA,WAAZ,MAA6B,wBAA7B;AAOA;AACA,OAAO,2BAAP;AACA,OAAO,2BAAP;AACA,OAAO,sBAAP;AACA,OAAO,0BAAP;AACA,OAAO,sCAAP;AACA,OAAO,uBAAP;AACA,OAAO,yBAAP;AACA,OAAO,mBAAP;AACA,OAAO,sBAAP;AACA,OAAO,uCAAP;AACA,OAAO,yBAAP;AACA,OAAO,wBAAP;AACA,OAAO,sBAAP;AACA,OAAO,wBAAP;AACA,OAAO,2BAAP;AACA,OAAO,0CAAP;AACA,OAAO,qBAAP;AACA,OAAO,uBAAP",
	"sourcesContent": [
		"/* eslint-disable import/no-extraneous-dependencies */\nimport * as dropEvent from '@interactjs/actions/drop/DropEvent'\nimport * as gesture from '@interactjs/actions/gesture/plugin'\nimport * as resize from '@interactjs/actions/resize/plugin'\nimport * as iEvent from '@interactjs/core/InteractEvent'\nimport * as iable from '@interactjs/core/Interactable'\nimport * as iSet from '@interactjs/core/InteractableSet'\nimport * as interaction from '@interactjs/core/Interaction'\nimport * as defaults from '@interactjs/core/defaultOptions'\nimport * as iStatic from '@interactjs/core/interactStatic'\nimport * as scope from '@interactjs/core/scope'\nimport * as snap from '@interactjs/modifiers/snap/pointer'\nimport { PointerEvent as _PointerEvent } from '@interactjs/pointer-events/PointerEvent'\n\n// import module augmentations\nimport '@interactjs/actions/drag/plugin'\nimport '@interactjs/actions/drop/plugin'\nimport '@interactjs/arrange/plugin'\nimport '@interactjs/auto-scroll/plugin'\nimport '@interactjs/auto-start/InteractableMethods'\nimport '@interactjs/auto-start/base'\nimport '@interactjs/auto-start/plugin'\nimport '@interactjs/core/events'\nimport '@interactjs/interact/index'\nimport '@interactjs/core/interactablePreventDefault'\nimport '@interactjs/core/interactions'\nimport '@interactjs/dev-tools/plugin'\nimport '@interactjs/inertia/plugin'\nimport '@interactjs/modifiers/plugin'\nimport '@interactjs/pointer-events/base'\nimport '@interactjs/pointer-events/interactableTargets'\nimport '@interactjs/reflow/plugin'\nimport '@interactjs/snappers/plugin'\n\nimport _NativePointerEventType from './NativePointerEventType'\n\nexport type OrBoolean<T> = {\n  [P in keyof T]: T[P] | boolean;\n}\n\nexport type Element = HTMLElement | SVGElement\nexport type Context = Document | Element\nexport type EventTarget = Window | Document | Element\nexport type Target = EventTarget | string\nexport type Plugin = scope.Plugin\nexport type Actions = scope.Actions\nexport type ActionProps<T extends scope.ActionName = any> = interaction.ActionProps<T>\nexport type Interactable = iable.Interactable\n/** @internal */ export type InteractableSet = iSet.InteractableSet\nexport type Scope = scope.Scope\n/** @interanal */ export type InteractStatic = iStatic.InteractStatic\nexport type Interaction<T extends scope.ActionName = any> = interaction.Interaction<T>\nexport type InteractionProxy<T extends scope.ActionName = any> = interaction.InteractionProxy<T>\nexport type PointerArgProps<T extends {} = {}> = interaction.PointerArgProps<T>\nexport type InteractEvent<\n  T extends keyof scope.ActionMap = never,\n  P extends iEvent.EventPhase = iEvent.EventPhase,\n> = iEvent.InteractEvent<T, P>\nexport type EventPhase = iEvent.EventPhase\nexport type Options = defaults.Options\nexport type ActionName = scope.ActionName\nexport type SignalArgs = scope.SignalArgs\nexport type DoPhaseArg<T extends ActionName, P extends EventPhase> = interaction.DoPhaseArg<T, P>\nexport type DoAnyPhaseArg = interaction.DoAnyPhaseArg\n\nexport type DragEvent = InteractEvent<'drag'>\nexport type DropEvent = dropEvent.DropEvent\nexport type ResizeEvent = resize.ResizeEvent\nexport type GestureEvent = gesture.GestureEvent\nexport type PointerEvent<T extends string = any> = _PointerEvent<T>\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexport interface Rect {\n  top: number\n  left: number\n  bottom: number\n  right: number\n  width?: number\n  height?: number\n}\n\nexport type FullRect = Required<Rect>\n\nexport type RectFunction<T extends any[]> = (...args: T) => Rect | Element\n\nexport type RectResolvable<T extends any[]> = Rect | string | Element | RectFunction<T>\n\nexport type Dimensions = Point & Size\n\nexport interface CoordsSetMember {\n  page: Point\n  client: Point\n  timeStamp: number\n}\n\nexport interface CoordsSet {\n  cur: CoordsSetMember\n  prev: CoordsSetMember\n  start: CoordsSetMember\n  delta: CoordsSetMember\n  velocity: CoordsSetMember\n}\n\nexport interface HasGetRect {\n  getRect (element: Element): Rect\n}\n\nexport interface InertiaOption {\n  resistance?: number\n  minSpeed?: number\n  endSpeed?: number\n  allowResume?: boolean\n  zeroResumeDelta?: boolean\n  smoothEndDuration?: number\n}\nexport type InertiaOptions = InertiaOption | boolean\n\nexport interface EdgeOptions {\n  top?: boolean | string | Element\n  left?: boolean | string | Element\n  bottom?: boolean | string | Element\n  right?: boolean | string | Element\n}\n\nexport type CursorChecker<T extends ActionName = any> =\n  (action: ActionProps<T>, interactable: Interactable, element: Element, interacting: boolean) => string\n\nexport interface ActionMethod<T> {\n  (this: Interactable): T\n  // eslint-disable-next-line no-undef\n  (this: Interactable, options: Partial<OrBoolean<T>> | boolean): typeof this\n}\n\nexport interface OptionMethod<T> {\n  (this: Interactable): T\n  // eslint-disable-next-line no-undef\n  (this: Interactable, options: T): typeof this\n}\n\nexport type PerActionDefaults = defaults.PerActionDefaults\nexport type OptionsArg = defaults.OptionsArg\n\nexport interface DraggableOptions extends PerActionDefaults {\n  startAxis?: 'x' | 'y' | 'xy'\n  lockAxis?: 'x' | 'y' | 'xy' | 'start'\n  oninertiastart?: ListenersArg\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface DropzoneOptions extends PerActionDefaults {\n  accept?: string | Element | (({ dropzone, draggableElement }: {\n    dropzone: Interactable\n    draggableElement: Element\n  }) => boolean)\n  // How the overlap is checked on the drop zone\n  overlap?: 'pointer' | 'center' | number\n  checker?: DropFunctionChecker\n\n  ondropactivate?: ListenersArg\n  ondropdeactivate?: ListenersArg\n  ondragenter?: ListenersArg\n  ondragleave?: ListenersArg\n  ondropmove?: ListenersArg\n  ondrop?: ListenersArg\n}\n\nexport type DropFunctionChecker = (\n  dragEvent: any, // related drag operation\n  event: any, // touch or mouse EventEmitter\n  dropped: boolean, // default checker result\n  dropzone: Interactable, // dropzone interactable\n  dropElement: Element, // drop zone element\n  draggable: Interactable, // draggable's Interactable\n  draggableElement: Element, // dragged element\n) => boolean\n\nexport interface ResizableOptions extends PerActionDefaults {\n  square?: boolean\n  preserveAspectRatio?: boolean\n  edges?: EdgeOptions | null\n  axis?: 'x' | 'y' | 'xy' // deprecated\n  invert?: 'none' | 'negate' | 'reposition'\n  margin?: number\n  squareResize?: boolean\n  oninertiastart?: ListenersArg\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface GesturableOptions extends PerActionDefaults {\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport type ActionChecker = (\n  pointerEvent: any,\n  defaultAction: string,\n  interactable: Interactable,\n  element: Element,\n  interaction: Interaction,\n) => ActionProps\n\nexport type OriginFunction = (target: Element) => Rect\nexport type SnapFunction = snap.SnapFunction\nexport type SnapTarget = snap.SnapTarget\n\nexport interface PointerEventsOptions {\n  holdDuration?: number\n  allowFrom?: string\n  ignoreFrom?: string\n  origin?: Rect | Point | string | Element | OriginFunction\n}\n\nexport type RectChecker = (element: Element)  => Rect\n\nexport type NativePointerEventType = typeof _NativePointerEventType\nexport type PointerEventType = MouseEvent | TouchEvent | NativePointerEventType | PointerEvent | InteractEvent\nexport type PointerType = MouseEvent | Touch | NativePointerEventType | PointerEvent | InteractEvent\n\nexport type EventTypes = string | ListenerMap | Array<(string | ListenerMap)>\n\nexport type Listener = (...args: any[]) => any\nexport type Listeners = ListenerMap | ListenerMap[]\nexport type ListenersArg = Listener | ListenerMap | Array<(Listener | ListenerMap)>\nexport interface ListenerMap {\n  [index: string]: ListenersArg | ListenersArg[]\n}\n\nexport type ArrayElementType<T> = T extends Array<infer P> ? P : never\n"
	]
}